{"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-25","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"01-25","excerpt":""},{"title":"关于我","text":"","path":"about/index.html","date":"01-25","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-25","excerpt":""},{"title":"标签","text":"这里是标签页你要怎样啊","path":"tags/index.html","date":"01-25","excerpt":""}],"posts":[{"title":"nodejs同时进行多个异步资源加载","text":"&ensp;&ensp;&ensp;&ensp;现在有这种情况:小明在学校忘记带身份证和学生证,小明去请假却必须要这两个证件(例子不恰当你们就不要管了).偏偏这两个证件落在了两个不同的地方.这时候小明就叫了两个朋友去帮他取回这两个资源.只有小明等到了这两个资源后,小明请假这个事件才能执行下去.我们在程序里不经常会遇到这种情况吗？ 一个方法需要等待两项(或者更多)资源后才能进行下去,比如我们需要一个文件的内容以及一个数据库查询结果.效率最大化,我们当然是想让两项资源同时去获取,而不是先进行一个获取资源行为让另一个获取资源行为等待着. Promise?promise主要是为了解决js中多个异步回调难以维护和控制的问题.我们想要最大效率化处理小明的问题,就可以这样做: Promise.all([fun1(), fun2()]).then(fun3()); fun1是小明朋友拿身份证,fun2是小明朋友拿学生证,fun3是小明请假… promise还可以这样:假如小明派了两个朋友去拿身份证,那么任何一个人拿到身份证都可以继续下去,就是 Promise.race([fun1(), fun2()]).then(fun3()); fun1是小明朋友a拿身份证,fun2是小明朋友2拿身份证,fun3…是小明拿到身份证后要做的事情(虽然事实上身份证只能一人拿到,但程序里两个朋友都可以拿到,只不过后来那个被丢弃了) 异步回调?异步回调(执行完一件事,才能接着往下执行),如果出现多次,就会产生多层嵌套,维护和控制异步过程非常的麻烦和困难(深有感触)Promise就可以非常灵活的调整它们,比如:123456789101112setTimeout(function () &#123; var i = 1; console.log(i); setTimeout(function () &#123; i++; console.log(i); setTimeout(function () &#123; i++; console.log(i); &#125;, 1000); &#125;, 1000);&#125;, 1000); 可以变成更好看的下面代码(除了最后一行,还是丑):12345678910function next(n)&#123; return new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; console.log(n) n++; resolve(n); &#125;, 1000); &#125;);&#125;next(1).then(next).then(next); 是不是很难理解？没事我也一头雾水.当我们执行next(1)的时候,在next函数中返回一个promise对象,一秒钟之后,输出1,然后通过resolve把n(就是 2)传递给then方法的第一个function,即next(2) ,然后再通过resolve把3传递给下一个next().没有了接下来的then方法,resolve(n)也不会执行下去了. 上面代码的最后一行是不合理的,我们应该在最后加上catch()方法,即next(1).then(next).then(next).catch(function(){…});用来处理上面next()方法体中执行reject(n)方法(别说了我知道上面没有,你就不能想像一下可能有).上面最后一行代码的任何then()方法中执行了reject(),都会跳过剩下的then()方法直接执行catch(). 还不得听那个什么什么月的话","path":"2018/07/21/Nodejs多资源加载/","date":"07-21","excerpt":"&ensp;&ensp;&ensp;&ensp;现在有这种情况:小明在学校忘记带身份证和学生证,小明去请假却必须要这两个证件(例子不恰当你们就不要管了).偏偏这两个证件落在了两个不同的地方.这时候小明就叫了两个朋友去帮他取回这两个资源.只有小明等到了这两个资源后,小明请假这个事件才能执行下去.我们在程序里不经常会遇到这种情况吗？","preview":"https://tohsakakuro.oss-cn-beijing.aliyuncs.com/picture/SilverSpace/picture_preview/67014903_p0.jpg"},{"title":"我们的伊莉雅看板娘居然有些不正常","text":"&ensp;&ensp;&ensp;&ensp;最开始的看板娘总是奇奇怪怪的。如果不缩放，看板娘就不够清晰可爱。如果大幅度缩放，她又不肯正眼看我。。。&ensp;&ensp;&ensp;&ensp;她是不是坏掉了？需要修理了？&ensp;&ensp;&ensp;&ensp;github hexo-helper-live2d 包中的一个小问题 问题描述在live2d缩放度不是1的时候，鼠标的区域不自然，角色不会跟着鼠标转头，就像是，鼠标放在哪里都像放在角色的左上角一样，她是不会往下看或者往右看的。 考虑分析在源码中缩放的原理是先定义一个长宽乘以缩放倍数的大画&lt;canvas&gt;,然后再调节画布的大小到正常,即让系统先绘制一个巨大的图像再使它变小来让图像缩放更清晰。在这就可以考虑，是不是初始化的画布大小限制了鼠标区域？ 案件测试立即着手进行测试，调节不同的缩放倍数。2倍缩放的时候，鼠标放到div最下端，角色能够达到平视。鼠标放到div最右端，角色能够达到直视。有些眉目了，那么再改变更高的缩放倍数。10倍。鼠标放到div最下端，角色依然是仰视，鼠标放到div最右端，角色还是朝左看！是的就是这样，鼠标对live2d的作用区域在第一次绘制画布的时候就确定并且不再更改了！而且，超出div之外的鼠标作用区域就会失效。 修改方案既然问题确定了，那么一切都好办了。那么我们先画一个正常大小的画布，在角色绘制完成后，鼠标区域固定了，然后我们让系统把角色拉大，再通过样式控制画布变小，这样不就一切正常了吗。。着手修改调试。123456789101112131415&lt;canvas id=&quot;$&#123;config.id&#125;&quot; width=&quot;$&#123;config.width&#125;&quot; height=&quot;$&#123;config.height&#125;&quot;&gt;&lt;/canvas&gt; &lt;style&gt;#$&#123;config.id&#125;&#123; position: fixed; width: $&#123;config.width&#125;px; height: $&#123;config.height&#125;px; opacity:$&#123;config.opacityDefault&#125;; $&#123;config.position&#125;: $&#123;config.horizontalOffset&#125;px; z-index: 999; pointer-events: none; bottom: $&#123;config.verticalOffset&#125;px;&#125;&lt;/style&gt;document.getElementById(&quot;$&#123;config.id&#125;&quot;).width = &apos;$&#123;config.width * config.scaling&#125;&apos;;document.getElementById(&quot;$&#123;config.id&#125;&quot;).height = &apos;$&#123;config.height * config.scaling&#125;&apos;; 好了，正常啦。","path":"2018/07/01/我们的伊莉雅看板娘居然有些不正常/","date":"07-01","excerpt":"&ensp;&ensp;&ensp;&ensp;最开始的看板娘总是奇奇怪怪的。如果不缩放，看板娘就不够清晰可爱。如果大幅度缩放，她又不肯正眼看我。。。&ensp;&ensp;&ensp;&ensp;她是不是坏掉了？需要修理了？&ensp;&ensp;&ensp;&ensp;github hexo-helper-live2d 包中的一个小问题","preview":"https://tohsakakuro.oss-cn-beijing.aliyuncs.com/picture/SilverSpace/picture_preview/66987311_p0.png"},{"title":"Oracle 偶记","text":"&ensp;&ensp;&ensp;&ensp;这几天公司要发布产品测试版本了,我负责准备了数据库的部署脚本&ensp;&ensp;&ensp;&ensp;本来对数据库不太熟悉,但也只能硬着头皮上了。在这里记录下遇到的一些问题。 某些情况下是能够看到回收站表的影子的在遍历一个库并向表字段添加注释的时候比如SELECT * FROM DBA_COL_COMMENTS WHERE OWNER = &#39;TOHSAKA_KURO&#39;发现了表名以 Bin&amp; 开头的表名，类似 Bin&amp;()#J$@IHeworjwo— 之类的表，这些表是Oracle 10g 之后的回收表，类似于windows系统回收站文件。这些表是被删除后重命名的。如果直接根据这个查询结果遍历添加表字段注释这肯定不行的。对于这些回收表是添加不上表字段注释的。所以我们需要从结果中剔除这些表。 一个笨方法是关联到 DBA_TABLES 表来查询正常的表。SELECT * FROM DBA_COL_COMMENTS DCC, DBA_TABLES DT WHERE DCC.TABLE_NAME = DT.TABLE_NAME AND DCC.OWNER = &#39;TOHSAKA_KURO&#39; 这样的话就可以对游标遍历并添加表字段注释了。 系统打印缓存是有上限的本来我是在每次执行语句之前都习惯性做系统打印。这次对于整个库遍历，循环有点多，然后我的习惯导致了服务器输出窗口被装满，无法继续输出。DBMS_OUTPUT.PUT_LINE()语句是不能用太多的，否则就会碰到像我一样的问题。 DECLARE 关键字是不能单独出现的DECLARE 之后一定要有 BEGIN END 关键字。刚开始我还纳闷怎么一直编译不通过。直到自己看了一眼提示。。。","path":"2018/03/16/oraclepractice/","date":"03-16","excerpt":"&ensp;&ensp;&ensp;&ensp;这几天公司要发布产品测试版本了,我负责准备了数据库的部署脚本&ensp;&ensp;&ensp;&ensp;本来对数据库不太熟悉,但也只能硬着头皮上了。在这里记录下遇到的一些问题。","preview":"http://tohsakakuro.oss-cn-beijing.aliyuncs.com/picture/SilverSpace/picture_preview/60790423_p1_master1200.jpg"}]}